# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

from sys import version_info
from os.path import dirname
import types
import traceback
import _libvariant

class Path(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Path, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Path, name)
    __repr__ = _swig_repr
    __swig_setmethods__["path"] = _libvariant.Path_path_set
    __swig_getmethods__["path"] = _libvariant.Path_path_get
    if _newclass:path = _swig_property(_libvariant.Path_path_get, _libvariant.Path_path_set)
    def __init__(self, *args): 
        """
        __init__(self, string p) -> Path

        1
        """
        this = _libvariant.new_Path(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvariant.delete_Path
    __del__ = lambda self : None;
Path_swigregister = _libvariant.Path_swigregister
Path_swigregister(Path)

class Handle(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Handle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Handle, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Handle
        __init__(self, dff_ui64 arg0) -> Handle
        __init__(self, string arg0) -> Handle
        __init__(self, dff_ui64 arg0, string arg1) -> Handle

        1
        """
        this = _libvariant.new_Handle(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["id"] = _libvariant.Handle_id_set
    __swig_getmethods__["id"] = _libvariant.Handle_id_get
    if _newclass:id = _swig_property(_libvariant.Handle_id_get, _libvariant.Handle_id_set)
    __swig_setmethods__["name"] = _libvariant.Handle_name_set
    __swig_getmethods__["name"] = _libvariant.Handle_name_get
    if _newclass:name = _swig_property(_libvariant.Handle_name_get, _libvariant.Handle_name_set)
    __swig_destroy__ = _libvariant.delete_Handle
    __del__ = lambda self : None;
Handle_swigregister = _libvariant.Handle_swigregister
Handle_swigregister(Handle)

class attrib(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, attrib, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, attrib, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(self) -> attrib

        1
        """
        this = _libvariant.new_attrib()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvariant.delete_attrib
    __del__ = lambda self : None;
    __swig_setmethods__["smap"] = _libvariant.attrib_smap_set
    __swig_getmethods__["smap"] = _libvariant.attrib_smap_get
    if _newclass:smap = _swig_property(_libvariant.attrib_smap_get, _libvariant.attrib_smap_set)
    __swig_setmethods__["time"] = _libvariant.attrib_time_set
    __swig_getmethods__["time"] = _libvariant.attrib_time_get
    if _newclass:time = _swig_property(_libvariant.attrib_time_get, _libvariant.attrib_time_set)
    __swig_setmethods__["imap"] = _libvariant.attrib_imap_set
    __swig_getmethods__["imap"] = _libvariant.attrib_imap_get
    if _newclass:imap = _swig_property(_libvariant.attrib_imap_get, _libvariant.attrib_imap_set)
    __swig_setmethods__["deleted"] = _libvariant.attrib_deleted_set
    __swig_getmethods__["deleted"] = _libvariant.attrib_deleted_get
    if _newclass:deleted = _swig_property(_libvariant.attrib_deleted_get, _libvariant.attrib_deleted_set)
    __swig_setmethods__["size"] = _libvariant.attrib_size_set
    __swig_getmethods__["size"] = _libvariant.attrib_size_get
    if _newclass:size = _swig_property(_libvariant.attrib_size_get, _libvariant.attrib_size_set)
    __swig_setmethods__["handle"] = _libvariant.attrib_handle_set
    __swig_getmethods__["handle"] = _libvariant.attrib_handle_get
    if _newclass:handle = _swig_property(_libvariant.attrib_handle_get, _libvariant.attrib_handle_set)
attrib_swigregister = _libvariant.attrib_swigregister
attrib_swigregister(attrib)

class typeId(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, typeId, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, typeId, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Invalid = _libvariant.typeId_Invalid
    String = _libvariant.typeId_String
    CArray = _libvariant.typeId_CArray
    Char = _libvariant.typeId_Char
    Int16 = _libvariant.typeId_Int16
    UInt16 = _libvariant.typeId_UInt16
    Int32 = _libvariant.typeId_Int32
    UInt32 = _libvariant.typeId_UInt32
    Int64 = _libvariant.typeId_Int64
    UInt64 = _libvariant.typeId_UInt64
    Bool = _libvariant.typeId_Bool
    Map = _libvariant.typeId_Map
    List = _libvariant.typeId_List
    VTime = _libvariant.typeId_VTime
    Node = _libvariant.typeId_Node
    VoidStar = _libvariant.typeId_VoidStar
    def Get():
        """
        Get() -> typeId

        1
        """
        return _libvariant.typeId_Get()

    if _newclass:Get = staticmethod(Get)
    __swig_getmethods__["Get"] = lambda x: Get
    def getType(self, *args):
        """
        getType(self, char type) -> uint8_t

        1
        """
        return _libvariant.typeId_getType(self, *args)

typeId_swigregister = _libvariant.typeId_swigregister
typeId_swigregister(typeId)

def typeId_Get():
  """
    typeId_Get() -> typeId

    1
    """
  return _libvariant.typeId_Get()

class Variant(_object):
    """
    Variants are designed to be a generic template type which can be used to store
    different type of data. This is useful for example while setting the extended
    attributes of a node : these attributes can be strings, integers, lists, etc.

    The type of the value is defined while creating the Variant object. To get the
    value back you just have to use the value() method.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variant, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Variant, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libvariant.delete_Variant
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> Variant
        __init__(self, string str) -> Variant
        __init__(self, char carray) -> Variant
        __init__(self, char c) -> Variant
        __init__(self, uint16_t us) -> Variant
        __init__(self, int16_t s) -> Variant
        __init__(self, uint32_t ui) -> Variant
        __init__(self, int32_t i) -> Variant
        __init__(self, int64_t ull) -> Variant
        __init__(self, uint64_t ll) -> Variant
        __init__(self, vtime vt) -> Variant
        __init__(self, Node node) -> Variant
        __init__(self, VList l) -> Variant
        __init__(self, VMap m) -> Variant
        __init__(self, void user) -> Variant

        Variants are designed to be a generic template type which can be used to store
        different type of data. This is useful for example while setting the extended
        attributes of a node : these attributes can be strings, integers, lists, etc.

        The type of the value is defined while creating the Variant object. To get the
        value back you just have to use the value() method.

        """
        this = _libvariant.new_Variant(*args)
        try: self.this.append(this)
        except: self.this = this
    def convert(self, *args):
        """
        convert(self, uint8_t itype, void res) -> bool

        This method is used to convert the value of the variant from one type to an other.

        """
        return _libvariant.Variant_convert(self, *args)

    def toString(self):
        """
        toString(self) -> string

        Convert the variant value to a string

        """
        return _libvariant.Variant_toString(self)

    def toUInt16(self):
        """
        toUInt16(self) -> uint16_t

        Convert the variant value to an unsigned integer 16 bits big.

        """
        return _libvariant.Variant_toUInt16(self)

    def toInt16(self):
        """
        toInt16(self) -> int16_t

        Convert the variant value to an integer 16 bits big

        """
        return _libvariant.Variant_toInt16(self)

    def toUInt32(self):
        """
        toUInt32(self) -> uint32_t

        Convert the variant value to an unsigned integer 32 bits big

        """
        return _libvariant.Variant_toUInt32(self)

    def toInt32(self):
        """
        toInt32(self) -> int32_t

        Convert the variant value to an integer 32 bits big.

        """
        return _libvariant.Variant_toInt32(self)

    def toUInt64(self):
        """
        toUInt64(self) -> uint64_t

        Convert the variant value to an unsigned integer 64 bits big.

        """
        return _libvariant.Variant_toUInt64(self)

    def toInt64(self):
        """
        toInt64(self) -> int64_t

        Convert the variant value to an integer 64 bits big.

        """
        return _libvariant.Variant_toInt64(self)

    def toBool(self):
        """
        toBool(self) -> bool

        Convert the variant value to a boolean

        """
        return _libvariant.Variant_toBool(self)

    def type(self):
        """
        type(self) -> uint8_t

        Return the type of the value stored in the variant.

        """
        return _libvariant.Variant_type(self)

    def __Char(self):
        """
        __Char(self) -> char

        1
        """
        return _libvariant.Variant___Char(self)

    def __Int16(self):
        """
        __Int16(self) -> short

        1
        """
        return _libvariant.Variant___Int16(self)

    def __UInt16(self):
        """
        __UInt16(self) -> unsigned short

        1
        """
        return _libvariant.Variant___UInt16(self)

    def __Int32(self):
        """
        __Int32(self) -> int

        1
        """
        return _libvariant.Variant___Int32(self)

    def __UInt32(self):
        """
        __UInt32(self) -> unsigned int

        1
        """
        return _libvariant.Variant___UInt32(self)

    def __Int64(self):
        """
        __Int64(self) -> long long

        1
        """
        return _libvariant.Variant___Int64(self)

    def __UInt64(self):
        """
        __UInt64(self) -> unsigned long long

        1
        """
        return _libvariant.Variant___UInt64(self)

    def __CArray(self):
        """
        __CArray(self) -> char

        1
        """
        return _libvariant.Variant___CArray(self)

    def __VTime(self):
        """
        __VTime(self) -> vtime

        1
        """
        return _libvariant.Variant___VTime(self)

    def __String(self):
        """
        __String(self) -> string

        1
        """
        return _libvariant.Variant___String(self)

    def __VList(self):
        """
        __VList(self) -> VList

        1
        """
        return _libvariant.Variant___VList(self)

    def __VMap(self):
        """
        __VMap(self) -> VMap

        1
        """
        return _libvariant.Variant___VMap(self)

    def __proxyinit__(self, *args):
        if len(args) == 1:
           if type(args[0]) in [type(VList), type(VMap)]:
              args[0].thisown = False
        self.__origininit__(*args)

    def __repr__(self):
        #if self.type() in [typeId.Char, typeId.CArray, typeId.String]:
           #buff = "'" + str(self.value()) + "'"
        #else:
        buff = str(self.value())
        return buff

    def value(self):
        valType = self.type()
        if valType in self.funcMapper.keys():
            func = getattr(self, self.funcMapper[valType])
            if func != None:
                return func()
            else:
                return None
        else:
            return None

Variant_swigregister = _libvariant.Variant_swigregister
Variant_swigregister(Variant)

Variant.__origininit__ = Variant.__init__
Variant.__init__ = Variant.__proxyinit__
Variant.funcMapper = {typeId.Char: "_Variant__Char",
                        typeId.Int16: "_Variant__Int16",
                        typeId.UInt16: "_Variant__UInt16",
                        typeId.Int32: "_Variant__Int32",
                        typeId.UInt32: "_Variant__UInt32",
                        typeId.Int64: "_Variant__Int64",
                        typeId.UInt64: "_Variant__UInt64",
                        typeId.String: "_Variant__String",
                        typeId.CArray: "_Variant__CArray",
                      typeId.Node: "_Variant__Node",
                        typeId.VTime: "_Variant__VTime",
          typeId.List: "_Variant__VList",
		          typeId.Map: "_Variant__VMap"}


import api.type.libtype
class VList(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VList, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        1
        """
        return _libvariant.VList_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        1
        """
        return _libvariant.VList___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        1
        """
        return _libvariant.VList___bool__(self)

    def __len__(self):
        """
        __len__(self) -> size_type

        1
        """
        return _libvariant.VList___len__(self)

    def pop(self):
        """
        pop(self) -> value_type

        1
        """
        return _libvariant.VList_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, difference_type i, difference_type j) -> VList

        1
        """
        return _libvariant.VList___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, VList v)

        1
        """
        return _libvariant.VList___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, difference_type i, difference_type j)

        1
        """
        return _libvariant.VList___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)

        1
        """
        return _libvariant.VList___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> VList
        __getitem__(self, difference_type i) -> value_type

        1
        """
        return _libvariant.VList___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, VList v)
        __setitem__(self, difference_type i, value_type x)

        1
        """
        return _libvariant.VList___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, value_type x)

        1
        """
        return _libvariant.VList_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        1
        """
        return _libvariant.VList_empty(self)

    def size(self):
        """
        size(self) -> size_type

        1
        """
        return _libvariant.VList_size(self)

    def clear(self):
        """
        clear(self)

        1
        """
        return _libvariant.VList_clear(self)

    def swap(self, *args):
        """
        swap(self, VList v)

        1
        """
        return _libvariant.VList_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> allocator_type

        1
        """
        return _libvariant.VList_get_allocator(self)

    def begin(self):
        """
        begin(self) -> const_iterator

        1
        """
        return _libvariant.VList_begin(self)

    def end(self):
        """
        end(self) -> const_iterator

        1
        """
        return _libvariant.VList_end(self)

    def rbegin(self):
        """
        rbegin(self) -> const_reverse_iterator

        1
        """
        return _libvariant.VList_rbegin(self)

    def rend(self):
        """
        rend(self) -> const_reverse_iterator

        1
        """
        return _libvariant.VList_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        1
        """
        return _libvariant.VList_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator

        1
        """
        return _libvariant.VList_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> VList
        __init__(self, VList arg0) -> VList
        __init__(self, size_type size) -> VList
        __init__(self, size_type size, value_type value) -> VList

        1
        """
        this = _libvariant.new_VList(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(self, value_type x)

        1
        """
        return _libvariant.VList_push_back(self, *args)

    def front(self):
        """
        front(self) -> value_type

        1
        """
        return _libvariant.VList_front(self)

    def back(self):
        """
        back(self) -> value_type

        1
        """
        return _libvariant.VList_back(self)

    def assign(self, *args):
        """
        assign(self, size_type n, value_type x)

        1
        """
        return _libvariant.VList_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)

        1
        """
        return _libvariant.VList_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)

        1
        """
        return _libvariant.VList_insert(self, *args)

    def pop_front(self):
        """
        pop_front(self)

        1
        """
        return _libvariant.VList_pop_front(self)

    def push_front(self, *args):
        """
        push_front(self, value_type x)

        1
        """
        return _libvariant.VList_push_front(self, *args)

    def remove(self, *args):
        """
        remove(self, value_type x)

        1
        """
        return _libvariant.VList_remove(self, *args)

    def unique(self):
        """
        unique(self)

        1
        """
        return _libvariant.VList_unique(self)

    def reverse(self):
        """
        reverse(self)

        1
        """
        return _libvariant.VList_reverse(self)

    def sort(self):
        """
        sort(self)

        1
        """
        return _libvariant.VList_sort(self)

    def merge(self, *args):
        """
        merge(self, VList x)

        1
        """
        return _libvariant.VList_merge(self, *args)

    __swig_destroy__ = _libvariant.delete_VList
    __del__ = lambda self : None;
VList_swigregister = _libvariant.VList_swigregister
VList_swigregister(VList)

class VMap(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VMap, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        1
        """
        return _libvariant.VMap_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        1
        """
        return _libvariant.VMap___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        1
        """
        return _libvariant.VMap___bool__(self)

    def __len__(self):
        """
        __len__(self) -> size_type

        1
        """
        return _libvariant.VMap___len__(self)

    def __getitem__(self, *args):
        """
        __getitem__(self, key_type key) -> mapped_type

        1
        """
        return _libvariant.VMap___getitem__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, key_type key)

        1
        """
        return _libvariant.VMap___delitem__(self, *args)

    def has_key(self, *args):
        """
        has_key(self, key_type key) -> bool

        1
        """
        return _libvariant.VMap_has_key(self, *args)

    def keys(self):
        """
        keys(self) -> PyObject

        1
        """
        return _libvariant.VMap_keys(self)

    def values(self):
        """
        values(self) -> PyObject

        1
        """
        return _libvariant.VMap_values(self)

    def items(self):
        """
        items(self) -> PyObject

        1
        """
        return _libvariant.VMap_items(self)

    def __contains__(self, *args):
        """
        __contains__(self, key_type key) -> bool

        1
        """
        return _libvariant.VMap___contains__(self, *args)

    def key_iterator(self):
        """
        key_iterator(self) -> SwigPyIterator

        1
        """
        return _libvariant.VMap_key_iterator(self)

    def value_iterator(self):
        """
        value_iterator(self) -> SwigPyIterator

        1
        """
        return _libvariant.VMap_value_iterator(self)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __setitem__(self, *args):
        """
        __setitem__(self, key_type key, mapped_type x)

        1
        """
        return _libvariant.VMap___setitem__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(std::string)> arg0) -> VMap
        __init__(self) -> VMap
        __init__(self, VMap arg0) -> VMap

        1
        """
        this = _libvariant.new_VMap(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """
        empty(self) -> bool

        1
        """
        return _libvariant.VMap_empty(self)

    def size(self):
        """
        size(self) -> size_type

        1
        """
        return _libvariant.VMap_size(self)

    def clear(self):
        """
        clear(self)

        1
        """
        return _libvariant.VMap_clear(self)

    def swap(self, *args):
        """
        swap(self, VMap v)

        1
        """
        return _libvariant.VMap_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> allocator_type

        1
        """
        return _libvariant.VMap_get_allocator(self)

    def begin(self):
        """
        begin(self) -> const_iterator

        1
        """
        return _libvariant.VMap_begin(self)

    def end(self):
        """
        end(self) -> const_iterator

        1
        """
        return _libvariant.VMap_end(self)

    def rbegin(self):
        """
        rbegin(self) -> const_reverse_iterator

        1
        """
        return _libvariant.VMap_rbegin(self)

    def rend(self):
        """
        rend(self) -> const_reverse_iterator

        1
        """
        return _libvariant.VMap_rend(self)

    def count(self, *args):
        """
        count(self, key_type x) -> size_type

        1
        """
        return _libvariant.VMap_count(self, *args)

    def erase(self, *args):
        """
        erase(self, key_type x) -> size_type
        erase(self, iterator position)
        erase(self, iterator first, iterator last)

        1
        """
        return _libvariant.VMap_erase(self, *args)

    def find(self, *args):
        """
        find(self, key_type x) -> iterator

        1
        """
        return _libvariant.VMap_find(self, *args)

    def lower_bound(self, *args):
        """
        lower_bound(self, key_type x) -> iterator

        1
        """
        return _libvariant.VMap_lower_bound(self, *args)

    def upper_bound(self, *args):
        """
        upper_bound(self, key_type x) -> iterator

        1
        """
        return _libvariant.VMap_upper_bound(self, *args)

    __swig_destroy__ = _libvariant.delete_VMap
    __del__ = lambda self : None;
VMap_swigregister = _libvariant.VMap_swigregister
VMap_swigregister(VMap)

########################################################
# Following method provides overload for VMap and VList#
########################################################
VariantType = str(type(Variant()))[8:-2]
VListType = str(type(VList()))[8:-2]
VMapType = str(type(VMap()))[8:-2]

baseManagedTypes = [types.BooleanType, types.IntType, types.LongType,
                    types.StringType, types.FloatType]

def create_container_from_item(item):
    if str(type(item)).find(VariantType) != -1 or str(type(item)).find(VListType) != -1 or str(type(item)).find(VMapType) != -1:
        item.thisown = False
        return item
    elif type(item) == types.ListType:
        vl = VList()
        vl.thisown = False
        for i in item:
            container = create_container_from_item(i)
            container.thisown = False
            vl.append(container)
        return vl
    elif type(item) == types.DictType:
        vm = VMap()
        vm.thisown = False
        for key, val in item.iteritems():
            strkey = str(key)
            container = create_container_from_item(val)
            container.thisown = False
            VMap[strkey] = container
        return vm
    elif type(item) in baseManagedTypes:
        vitem = Variant(item)
        vitem.thisown = False
        return vitem
    else:
        TypeError("Management of type " + str(type(item)) + " is not implemented")


def create_variant_from_item(item):
    try:
        if str(type(item)).find(VariantType) != -1:
            return item
        else:
            vitem = create_container_from_item(item)
            if str(type(vitem)).find(VListType) != -1 or str(type(vitem)).find(VMapType) != -1:
                vvitem = Variant(vitem)
                vvitem.thisown = False
                return vvitem
            else:
                return vitem
    except(TypeError):
        traceback.print_exc()
        return None


# Wrapping methods for VList
def __vlist_proxyinit__(self, *args):
    self.__originit__()
    if len(args) >= 1:
        for arg in args:
            self.append(arg)

VList.__originit__ = VList.__init__
VList.__init__ = __vlist_proxyinit__


def vlist_append_proxy(self, item):
    vitem = create_variant_from_item(item)
    if vitem != None:
        self.__origappend__(vitem)

VList.__origappend__ = VList.append
VList.append = vlist_append_proxy


def vlist_setitem_proxy(self, *args):
    witem = create_variant_from_item(args[1])
    self.__orig_setitem__(args[0], witem)
    
VList.__orig_setitem__ = VList.__setitem__
VList.__setitem__ = vlist_setitem_proxy


def __vlist_repr__(self):
    buff = "["
    lsize = self.size()
    i = 0
    for item in self.iterator():
        i += 1
        buff += repr(item)
        if i < lsize:
            buff += ", "
    buff += "]"
    return buff


VList.__orig_repr__ = VList.__repr__
VList.__repr__ = __vlist_repr__


# Wrapping methods for VMap
def __vmap_setitem_proxy__(self, *args):
    witem = create_variant_from_item(args[1])
    self.__orig_setitem__(args[0], witem)

VMap.__orig_setitem__ = VMap.__setitem__
VMap.__setitem__ =  __vmap_setitem_proxy__


def __vmap_repr_proxy__(self):
    buff = "{"
    msize = self.size()
    i = 0
    for key, val in self.iteritems():
        i += 1
        buff += repr(key) + ": " + repr(val)
        if i < msize:
            buff += ", "
    buff += "}"
    return buff

VMap.__orig_repr__ = VMap.__repr__
VMap.__repr__ = __vmap_repr_proxy__



