# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

from sys import version_info
from os.path import dirname
import types
import traceback
import _libvariant


"""
libvariant : this module contains all classes required to manipulate Variant types.

Variant types are a generic type of data which can be used to manipulate
"""


class Path(object):
    """1"""
    def __init__(self, *args): 
        """
        __init__(self, string p) -> Path

        1
        """
        this = _libvariant.new_Path(*args)
        try: self.this.append(this)
        except: self.this = this

class Handle(object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Handle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Handle, name)
    def __init__(self, *args): 
        """
        __init__(self) -> Handle
        __init__(self, dff_ui64 arg0) -> Handle
        __init__(self, string arg0) -> Handle
        __init__(self, dff_ui64 arg0, string arg1) -> Handle

        1
        """

class attrib(object):
    """1"""

    def __init__(self): 
        """
        __init__(self) -> attrib

        1
        """

class typeId(object):
    """1"""

    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")

    def Get():
        """
        Get() -> typeId

        1
        """
        return _libvariant.typeId_Get()

    def getType(self, *args):
        """
        getType(self, char type) -> uint8_t

        1
        """
        return _libvariant.typeId_getType(self, *args)

def typeId_Get():
  """
    typeId_Get() -> typeId

    1
    """
  return _libvariant.typeId_Get()

class Variant(object):
    """
    Variants are designed to be a generic template type which can be used to store
    different type of data. This is useful for example while setting the extended
    attributes of a node : these attributes can be strings, integers, lists, etc.

    The type of the value is defined while creating the Variant object. To get the
    value back you just have to use the value() method.

    """

    def __init__(self, *args): 
        """
        __init__(self) -> Variant
        __init__(self, string str) -> Variant
        __init__(self, char carray) -> Variant
        __init__(self, char c) -> Variant
        __init__(self, uint16_t us) -> Variant
        __init__(self, int16_t s) -> Variant
        __init__(self, uint32_t ui) -> Variant
        __init__(self, int32_t i) -> Variant
        __init__(self, int64_t ull) -> Variant
        __init__(self, uint64_t ll) -> Variant
        __init__(self, vtime vt) -> Variant
        __init__(self, Node node) -> Variant
        __init__(self, VList l) -> Variant
        __init__(self, VMap m) -> Variant
        __init__(self, void user) -> Variant

        Variants are designed to be a generic template type which can be used to store
        different type of data. This is useful for example while setting the extended
        attributes of a node : these attributes can be strings, integers, lists, etc.

        The type of the value is defined while creating the Variant object. To get the
        value back you just have to use the value() method.

        """

    def convert(self, *args):
        """
        convert(self, uint8_t itype, void res) -> bool

        This method is used to convert the value of the variant from one type to an other.

        """
        return _libvariant.Variant_convert(self, *args)

    def toString(self):
        """
        toString(self) -> string

        Convert the variant value to a string

        """
        return _libvariant.Variant_toString(self)

    def toUInt16(self):
        """
        toUInt16(self) -> uint16_t

        Convert the variant value to an unsigned integer 16 bits big.

        """
        return _libvariant.Variant_toUInt16(self)

    def toInt16(self):
        """
        toInt16(self) -> int16_t

        Convert the variant value to an integer 16 bits big

        """
        return _libvariant.Variant_toInt16(self)

    def toUInt32(self):
        """
        toUInt32(self) -> uint32_t

        Convert the variant value to an unsigned integer 32 bits big

        """
        return _libvariant.Variant_toUInt32(self)

    def toInt32(self):
        """
        toInt32(self) -> int32_t

        Convert the variant value to an integer 32 bits big.

        """
        return _libvariant.Variant_toInt32(self)

    def toUInt64(self):
        """
        toUInt64(self) -> uint64_t

        Convert the variant value to an unsigned integer 64 bits big.

        """
        return _libvariant.Variant_toUInt64(self)

    def toInt64(self):
        """
        toInt64(self) -> int64_t

        Convert the variant value to an integer 64 bits big.

        """
        return _libvariant.Variant_toInt64(self)

    def toBool(self):
        """
        toBool(self) -> bool

        Convert the variant value to a boolean

        """
        return _libvariant.Variant_toBool(self)

    def type(self):
        """
        type(self) -> uint8_t

        Return the type of the value stored in the variant.

        """
        return _libvariant.Variant_type(self)

    def __Char(self):
        """
        __Char(self) -> char

        1
        """
        return _libvariant.Variant___Char(self)

    def __Int16(self):
        """
        __Int16(self) -> short

        1
        """
        return _libvariant.Variant___Int16(self)

    def __UInt16(self):
        """
        __UInt16(self) -> unsigned short

        1
        """
        return _libvariant.Variant___UInt16(self)

    def __Int32(self):
        """
        __Int32(self) -> int

        1
        """
        return _libvariant.Variant___Int32(self)

    def __UInt32(self):
        """
        __UInt32(self) -> unsigned int

        1
        """
        return _libvariant.Variant___UInt32(self)

    def __Int64(self):
        """
        __Int64(self) -> long long

        1
        """
        return _libvariant.Variant___Int64(self)

    def __UInt64(self):
        """
        __UInt64(self) -> unsigned long long

        1
        """
        return _libvariant.Variant___UInt64(self)

    def __CArray(self):
        """
        __CArray(self) -> char

        1
        """
        return _libvariant.Variant___CArray(self)

    def __VTime(self):
        """
        __VTime(self) -> vtime

        1
        """
        return _libvariant.Variant___VTime(self)

    def __String(self):
        """
        __String(self) -> string

        1
        """
        return _libvariant.Variant___String(self)

    def __VList(self):
        """
        __VList(self) -> VList

        1
        """
        return _libvariant.Variant___VList(self)

    def __VMap(self):
        """
        __VMap(self) -> VMap

        1
        """
        return _libvariant.Variant___VMap(self)

    def __proxyinit__(self, *args):
        if len(args) == 1:
           if type(args[0]) in [type(VList), type(VMap)]:
              args[0].thisown = False
        self.__origininit__(*args)

    def __repr__(self):
        #if self.type() in [typeId.Char, typeId.CArray, typeId.String]:
           #buff = "'" + str(self.value()) + "'"
        #else:
        buff = str(self.value())
        return buff

    def value(self):
        valType = self.type()
        if valType in self.funcMapper.keys():
            func = getattr(self, self.funcMapper[valType])
            if func != None:
                return func()
            else:
                return None
        else:
            return None


class VList(object):
    """1"""

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        1
        """
        return _libvariant.VList_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        1
        """
        return _libvariant.VList___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        1
        """
        return _libvariant.VList___bool__(self)

    def __len__(self):
        """
        __len__(self) -> size_type

        1
        """
        return _libvariant.VList___len__(self)

    def pop(self):
        """
        pop(self) -> value_type

        1
        """
        return _libvariant.VList_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, difference_type i, difference_type j) -> VList

        1
        """
        return _libvariant.VList___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, VList v)

        1
        """
        return _libvariant.VList___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, difference_type i, difference_type j)

        1
        """
        return _libvariant.VList___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)

        1
        """
        return _libvariant.VList___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> VList
        __getitem__(self, difference_type i) -> value_type

        1
        """
        return _libvariant.VList___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, VList v)
        __setitem__(self, difference_type i, value_type x)

        1
        """
        return _libvariant.VList___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, value_type x)

        1
        """
        return _libvariant.VList_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        1
        """
        return _libvariant.VList_empty(self)

    def size(self):
        """
        size(self) -> size_type

        1
        """
        return _libvariant.VList_size(self)

    def clear(self):
        """
        clear(self)

        1
        """
        return _libvariant.VList_clear(self)

    def swap(self, *args):
        """
        swap(self, VList v)

        1
        """
        return _libvariant.VList_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> allocator_type

        1
        """
        return _libvariant.VList_get_allocator(self)

    def begin(self):
        """
        begin(self) -> const_iterator

        1
        """
        return _libvariant.VList_begin(self)

    def end(self):
        """
        end(self) -> const_iterator

        1
        """
        return _libvariant.VList_end(self)

    def rbegin(self):
        """
        rbegin(self) -> const_reverse_iterator

        1
        """
        return _libvariant.VList_rbegin(self)

    def rend(self):
        """
        rend(self) -> const_reverse_iterator

        1
        """
        return _libvariant.VList_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        1
        """
        return _libvariant.VList_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator

        1
        """
        return _libvariant.VList_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> VList
        __init__(self, VList arg0) -> VList
        __init__(self, size_type size) -> VList
        __init__(self, size_type size, value_type value) -> VList

        1
        """

    def push_back(self, *args):
        """
        push_back(self, value_type x)

        1
        """
        return _libvariant.VList_push_back(self, *args)

    def front(self):
        """
        front(self) -> value_type

        1
        """
        return _libvariant.VList_front(self)

    def back(self):
        """
        back(self) -> value_type

        1
        """
        return _libvariant.VList_back(self)

    def assign(self, *args):
        """
        assign(self, size_type n, value_type x)

        1
        """
        return _libvariant.VList_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)

        1
        """
        return _libvariant.VList_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)

        1
        """
        return _libvariant.VList_insert(self, *args)

    def pop_front(self):
        """
        pop_front(self)

        1
        """
        return _libvariant.VList_pop_front(self)

    def push_front(self, *args):
        """
        push_front(self, value_type x)

        1
        """
        return _libvariant.VList_push_front(self, *args)

    def remove(self, *args):
        """
        remove(self, value_type x)

        1
        """
        return _libvariant.VList_remove(self, *args)

    def unique(self):
        """
        unique(self)

        1
        """
        return _libvariant.VList_unique(self)

    def reverse(self):
        """
        reverse(self)

        1
        """
        return _libvariant.VList_reverse(self)

    def sort(self):
        """
        sort(self)

        1
        """
        return _libvariant.VList_sort(self)

    def merge(self, *args):
        """
        merge(self, VList x)

        1
        """
        return _libvariant.VList_merge(self, *args)

class VMap(object):
    """1"""

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        1
        """
        return _libvariant.VMap_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        1
        """
        return _libvariant.VMap___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        1
        """
        return _libvariant.VMap___bool__(self)

    def __len__(self):
        """
        __len__(self) -> size_type

        1
        """
        return _libvariant.VMap___len__(self)

    def __getitem__(self, *args):
        """
        __getitem__(self, key_type key) -> mapped_type

        1
        """
        return _libvariant.VMap___getitem__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, key_type key)

        1
        """
        return _libvariant.VMap___delitem__(self, *args)

    def has_key(self, *args):
        """
        has_key(self, key_type key) -> bool

        1
        """
        return _libvariant.VMap_has_key(self, *args)

    def keys(self):
        """
        keys(self) -> PyObject

        1
        """
        return _libvariant.VMap_keys(self)

    def values(self):
        """
        values(self) -> PyObject

        1
        """
        return _libvariant.VMap_values(self)

    def items(self):
        """
        items(self) -> PyObject

        1
        """
        return _libvariant.VMap_items(self)

    def __contains__(self, *args):
        """
        __contains__(self, key_type key) -> bool

        1
        """
        return _libvariant.VMap___contains__(self, *args)

    def key_iterator(self):
        """
        key_iterator(self) -> SwigPyIterator

        1
        """
        return _libvariant.VMap_key_iterator(self)

    def value_iterator(self):
        """
        value_iterator(self) -> SwigPyIterator

        1
        """
        return _libvariant.VMap_value_iterator(self)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __setitem__(self, *args):
        """
        __setitem__(self, key_type key, mapped_type x)

        1
        """
        return _libvariant.VMap___setitem__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(std::string)> arg0) -> VMap
        __init__(self) -> VMap
        __init__(self, VMap arg0) -> VMap

        1
        """

    def empty(self):
        """
        empty(self) -> bool

        1
        """
        return _libvariant.VMap_empty(self)

    def size(self):
        """
        size(self) -> size_type

        1
        """
        return _libvariant.VMap_size(self)

    def clear(self):
        """
        clear(self)

        1
        """
        return _libvariant.VMap_clear(self)

    def swap(self, *args):
        """
        swap(self, VMap v)

        1
        """
        return _libvariant.VMap_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> allocator_type

        1
        """
        return _libvariant.VMap_get_allocator(self)

    def begin(self):
        """
        begin(self) -> const_iterator

        1
        """
        return _libvariant.VMap_begin(self)

    def end(self):
        """
        end(self) -> const_iterator

        1
        """
        return _libvariant.VMap_end(self)

    def rbegin(self):
        """
        rbegin(self) -> const_reverse_iterator

        1
        """
        return _libvariant.VMap_rbegin(self)

    def rend(self):
        """
        rend(self) -> const_reverse_iterator

        1
        """
        return _libvariant.VMap_rend(self)

    def count(self, *args):
        """
        count(self, key_type x) -> size_type

        1
        """
        return _libvariant.VMap_count(self, *args)

    def erase(self, *args):
        """
        erase(self, key_type x) -> size_type
        erase(self, iterator position)
        erase(self, iterator first, iterator last)

        1
        """
        return _libvariant.VMap_erase(self, *args)

    def find(self, *args):
        """
        find(self, key_type x) -> iterator

        1
        """
        return _libvariant.VMap_find(self, *args)

    def lower_bound(self, *args):
        """
        lower_bound(self, key_type x) -> iterator

        1
        """
        return _libvariant.VMap_lower_bound(self, *args)

    def upper_bound(self, *args):
        """
        upper_bound(self, key_type x) -> iterator

        1
        """
        return _libvariant.VMap_upper_bound(self, *args)


########################################################
# Following method provides overload for VMap and VList#
########################################################
VariantType = str(type(Variant()))[8:-2]
VListType = str(type(VList()))[8:-2]
VMapType = str(type(VMap()))[8:-2]

baseManagedTypes = [types.BooleanType, types.IntType, types.LongType,
                    types.StringType, types.FloatType]

def create_container_from_item(item):
    if str(type(item)).find(VariantType) != -1 or str(type(item)).find(VListType) != -1 or str(type(item)).find(VMapType) != -1:
        item.thisown = False
        return item
    elif type(item) == types.ListType:
        vl = VList()
        vl.thisown = False
        for i in item:
            container = create_container_from_item(i)
            container.thisown = False
            vl.append(container)
        return vl
    elif type(item) == types.DictType:
        vm = VMap()
        vm.thisown = False
        for key, val in item.iteritems():
            strkey = str(key)
            container = create_container_from_item(val)
            container.thisown = False
            VMap[strkey] = container
        return vm
    elif type(item) in baseManagedTypes:
        vitem = Variant(item)
        vitem.thisown = False
        return vitem
    else:
        TypeError("Management of type " + str(type(item)) + " is not implemented")


def create_variant_from_item(item):
    try:
        if str(type(item)).find(VariantType) != -1:
            return item
        else:
            vitem = create_container_from_item(item)
            if str(type(vitem)).find(VListType) != -1 or str(type(vitem)).find(VMapType) != -1:
                vvitem = Variant(vitem)
                vvitem.thisown = False
                return vvitem
            else:
                return vitem
    except(TypeError):
        traceback.print_exc()
        return None


# Wrapping methods for VList
def __vlist_proxyinit__(self, *args):
    self.__originit__()
    if len(args) >= 1:
        for arg in args:
            self.append(arg)

VList.__originit__ = VList.__init__
VList.__init__ = __vlist_proxyinit__


def vlist_append_proxy(self, item):
    vitem = create_variant_from_item(item)
    if vitem != None:
        self.__origappend__(vitem)

VList.__origappend__ = VList.append
VList.append = vlist_append_proxy


def vlist_setitem_proxy(self, *args):
    witem = create_variant_from_item(args[1])
    self.__orig_setitem__(args[0], witem)
    
VList.__orig_setitem__ = VList.__setitem__
VList.__setitem__ = vlist_setitem_proxy


def __vlist_repr__(self):
    buff = "["
    lsize = self.size()
    i = 0
    for item in self.iterator():
        i += 1
        buff += repr(item)
        if i < lsize:
            buff += ", "
    buff += "]"
    return buff


VList.__orig_repr__ = VList.__repr__
VList.__repr__ = __vlist_repr__


# Wrapping methods for VMap
def __vmap_setitem_proxy__(self, *args):
    witem = create_variant_from_item(args[1])
    self.__orig_setitem__(args[0], witem)

VMap.__orig_setitem__ = VMap.__setitem__
VMap.__setitem__ =  __vmap_setitem_proxy__


def __vmap_repr_proxy__(self):
    buff = "{"
    msize = self.size()
    i = 0
    for key, val in self.iteritems():
        i += 1
        buff += repr(key) + ": " + repr(val)
        if i < msize:
            buff += ", "
    buff += "}"
    return buff

VMap.__orig_repr__ = VMap.__repr__
VMap.__repr__ = __vmap_repr_proxy__



