# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
libvfs: This module contains different classes used to manipulate  the virtul file system :
        * Node creation
        * Opening nodes
        * file descriptors manipulation
        * etc

"""

from sys import version_info

class DEvent(object):
    """1"""
    def __init__(self): 
        """
        __init__(self) -> DEvent

        1
        """
class DEventHandler(object):
    """1"""
    def __init__(self): 
        """
        __init__(self) -> DEventHandler

        1
        """
        if self.__class__ == DEventHandler:
            _self = None
        else:
            _self = self

    def Event(self, *args):
        """
        Event(self,  e)

        1
        """


    def connection(self, *args):
        """
        connection(self, DEventHandler obs) -> bool

        1
        """
        return _libvfs.DEventHandler_connection(self, *args)

    def deconnection(self, *args):
        """
        deconnection(self, DEventHandler obs) -> bool

        1
        """


    def notify(self, *args):
        """
        notify(self,  e) -> bool

        1
        """


    def __disown__(self):
        self.this.disown()

        return weakref_proxy(self)

class VFS(DEventHandler):
    """    
    Inherits DEventHandler

    """

    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")

    def Get():
        """
        Get() -> VFS

        1
        """
        return _libvfs.VFS_Get()

    Get = staticmethod(Get)
    def GetTree(self):
        """
        GetTree(self) -> SetNode

        1
        """
        return _libvfs.VFS_GetTree(self)

    def cd(self, *args):
        """
        cd(self, Node arg0)

        1
        """
        return _libvfs.VFS_cd(self, *args)

    def GetCWD(self):
        """
        GetCWD(self) -> Node

        1
        """
        return _libvfs.VFS_GetCWD(self)

    def GetNode(self, *args):
        """
        GetNode(self, string path) -> Node
        GetNode(self, string path, Node where) -> Node

        1
        """
        return _libvfs.VFS_GetNode(self, *args)

    def getNodeFromPointer(self, *args):
        """
        getNodeFromPointer(self, unsigned int pnode) -> PyObject

        1
        """
        return _libvfs.VFS_getNodeFromPointer(self, *args)


def VFS_Get():
  """
    VFS_Get() -> VFS

    1
    """
  return _libvfs.VFS_Get()

class chunck(object):
    """1"""

    def __init__(self): 
        """
        __init__(self) -> chunck

        1
        """

class FileMapping(object):
    """
    This class is used to map a file in the vfile.
    More precisely, it contains a list a chuncks containing the different offsets
    of the file blocks on the vfile. Indeed, do not forget that bytes contained
    in node are not necessarly contiguous in memory. In the worst case which should never happen it is theorically possible
    that there are not any contiguous blocks. Each chuncks are used to describe one of these different positions on the vfile
    by providing two major informations :
        * the offset of the data on the vfile
        * the size it occupies
    
    It means that each chuncks define a range of data starting at a given offset and
    occupying a given number of bytes.
    For example, lets imagine we open a 100 bytes big node which is fragmented in
    three parts. When mapping the file, three chuncks will be created and will look
    like this :
        * chunck 1 => offset : x; size : s bytes
        * chunck 1 => offset : y; size : t bytes
        * chunck 1 => offset : z; size : u bytes
    
    The sum s + t + u should be equal to the file size.
    The \"main\" method of FileMapping class is push, which must be called to
    create the different chuncks.

    """

    def __init__(self): 
        """
        __init__(self) -> FileMapping

        Constructor.
        """

    def mappedFileSize(self):
        """
        mappedFileSize(self) -> uint64_t
        
        Return the total size of the different chuncks. Should be equal to the node
        size.
        """


    def chunckCount(self):
        """
        chunckCount(self) -> uint32_t

        Return the number of mapped chuncks.
        """


    def firstChunck(self):
        """
        firstChunck(self) -> chunck \*

        Return a pointer to the first chunck of the list.
        """
        return _libvfs.FileMapping_firstChunck(self)

    def lastChunck(self):
        """
        lastChunck(self) -> chunck \*

        Return a pointer to the last chunck of the list.
        """
        return _libvfs.FileMapping_lastChunck(self)

    def chunckFromIdx(self, *args):
        """
        chunckFromIdx(self, uint32_t idx) -> chunck \*

        Return a pointer on the chunck structure corresponding to index `idx`
        in the list of chunck.
        """
        return _libvfs.FileMapping_chunckFromIdx(self, *args)

    def chunckFromOffset(self, *args):
        """
        chunckFromOffset(self, uint64_t offset) -> chunck \*

        Return a pointer to the chunck in which offset `offset` is.
        """
        return _libvfs.FileMapping_chunckFromOffset(self, *args)

    def chunckIdxFromOffset(self, *args):
        """
        chunckIdxFromOffset(self, uint64_t offset, uint32_t begidx = 0) -> uint32_t
        chunckIdxFromOffset(self, uint64_t offset) -> uint32_t

        """
        return _libvfs.FileMapping_chunckIdxFromOffset(self, *args)

    def chuncksFromOffsetRange(self, *args):
        """
        chuncksFromOffsetRange(self, uint64_t begoffset, uint64_t endoffset) -> VectChunck

        """
        return _libvfs.FileMapping_chuncksFromOffsetRange(self, *args)

    def chuncksFromIdxRange(self, *args):
        """
        chuncksFromIdxRange(self, uint32_t begidx, uint32_t endidx) -> VectChunck

        1
        """
        return _libvfs.FileMapping_chuncksFromIdxRange(self, *args)

    def chuncks(self):
        """
        chuncks(self) -> VectChunck

        Return a std::vector<chunck \*> which is the list of all mapped chuncks.
        The vector is empty if no chuncks are mapped.
        """
        return _libvfs.FileMapping_chuncks(self)

    def push(self, *args):
        """
        push(self, uint64_t offset, uint64_t size, Node origin = None,  uint64_t originoffset = 0)
        push(self, uint64_t offset, uint64_t size, Node origin = None)
        push(self, uint64_t offset, uint64_t size)

        Creating a chunck.

        Params :
                * offset : offset of the chunck in the file
                * size : the size of the chunck.
                * origin : the origin node created by the module.
                * originoffset : the real offset of the beginning of the chunck on the vfile
        """
        return _libvfs.FileMapping_push(self, *args)


class Attributes(object):
    """
    The Attributes class is designed to store a list of  attributes related to
    a Node, such as, among others, time informations, file mode or UNIX access rights
    for example.

    Each attributes are made of a string describing the attribute and a value, which
    is Variant type. For more precisions on Variant, see the Variant documentation.
    """

    def __init__(self): 
        """
        __init__(self) -> Attributes

        Constructor.
        """
        _libvfs.Attributes_swiginit(self,_libvfs.new_Attributes())

    def push(self, *args):
        """
        push(self, string key, Variant value)

        Add an attribute to the attributes list.

        Params :
                * key : the description of the attributes.
                * value : the value of the attribute

        """
        return _libvfs.Attributes_push(self, *args)

    def keys(self):
        """
        keys(self) -> std::list<(std::string,std::allocator<(std::string)>)>

        Returns a std::list<std::string> where each values are a key of attributes.
        """
        return _libvfs.Attributes_keys(self)

    def value(self, *args):
        """
        value(self, string key) -> Variant
        
        Return the value of the attributes which key is `key`
        """
        return _libvfs.Attributes_value(self, *args)

    def attributes(self):
        """
        attributes(self) -> std::map<(std::string,p.Variant,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.Variant)>)>)>

        Return a std::map<std::string, Variant \*> which contains the entire list of attributes
        """
        return _libvfs.Attributes_attributes(self)


class Node(object):
    """
    This class is the base interface of every nodes reprensented in DFF virtual file
    system tree view. Most of the modules will have to extend this class before using
    it, that is why some of the methods are virtual.

    """
    def __init__(self, *args): 
        """
        __init__(self, string name, uint64_t size = 0, Node parent = None,  fso fsobj = None) -> Node
        __init__(self, string name, uint64_t size = 0, Node parent = None) -> Node
        __init__(self, string name, uint64_t size = 0) -> Node
        __init__(self, string name) -> Node
        __init__(self) -> Node

        This class is the base interface of every nodes reprensented in DFF virtual file
        system tree view. Most of the modules will have to extend this class before using
        it, that is why some of the methods are virtual.

        """
        if self.__class__ == Node:
            _self = None
        else:
            _self = self
        _libvfs.Node_swiginit(self,_libvfs.new_Node(_self, *args))

    def setId(self, *args):
        """
        setId(self, uint32_t id)

        Set an ID of type uint32_t

        Params :
                * id : the id you want to set to node.
        """
        return _libvfs.Node_setId(self, *args)

    def id(self):
        """
        id(self) -> uint32_t

        Return the ID.
        """
        return _libvfs.Node_id(self)

    def setFile(self):
        """
        setFile(self)

        If the node is a file this method should be called to set proper attributes.

        """
        return _libvfs.Node_setFile(self)

    def setDir(self):
        """
        setDir(self)

        If the node is a directory this method should be called to set proper attributes.

        """
        return _libvfs.Node_setDir(self)

    def setLink(self):
        """
        setLink(self)

        If the node is a link this method should be called to set proper attributes.

        """
        return _libvfs.Node_setLink(self)

    def setDeleted(self):
        """
        setDeleted(self)

        If the node corresponds to a data which was deleted (and recovered by the
        module), this method should be called to set proper attributes.

        """
        return _libvfs.Node_setDeleted(self)

    def setSize(self, *args):
        """
        setSize(self, uint64_t size)

        Set the node size in bytes.

        """
        return _libvfs.Node_setSize(self, *args)

    def setFsobj(self, *args):
        """
        setFsobj(self, fso obj)

        Set a fso object.

        """
        return _libvfs.Node_setFsobj(self, *args)

    def setParent(self, *args):
        """
        setParent(self, Node parent)

        Set the parent's node of the current node.

        """
        return _libvfs.Node_setParent(self, *args)

    def fileMapping(self, *args):
        """
        fileMapping(self, FileMapping arg0)

        The fileMapping method takes a pointer to an instance of a FileMapping object
        as parameter. This method is called when a node is opened.

        The fileMapping method must "filled up" the FileMapping object which was passed
        to it by creating chuncks of the files. A chunck is a structure containing 2
        important informations :
         * The size (in bytes) of the chunck
         * Its address on the vfile.

        In human speakable langugage it means that the FileMapping structure contains
        a list of data structure, each of them giving a part of the file content position
        on the vfile.

        FileMapping can be filled up by calling their push() method.

        """
        return _libvfs.Node_fileMapping(self, *args)

    def setStaticAttribute(self, *args):
        """
        setStaticAttribute(self, string key, Variant value)

        Set static attributes to a node.

        """
        return _libvfs.Node_setStaticAttribute(self, *args)

    def staticAttributes(self):
        """
        staticAttributes(self) -> Attributes

        Get the static attributes from the node.

        """
        return _libvfs.Node_staticAttributes(self)

    def extendedAttributes(self, *args):
        """
        extendedAttributes(self, Attributes arg0)

        This method is used to set extended attributes to a node. It takes a pointer
        to an Attributes instance as parameter. This parameter can be filled up with
        attributes of any types by using the Variant type.

        ExtendedAttributes can be filled up by calling their push() method.

        """
        return _libvfs.Node_extendedAttributes(self, *args)

    def modifiedTime(self, *args):
        """
        modifiedTime(self, vtime arg0)

        Set the time of last modification

        """
        return _libvfs.Node_modifiedTime(self, *args)

    def accessedTime(self, *args):
        """
        accessedTime(self, vtime arg0)

        Set the time of last access

        """
        return _libvfs.Node_accessedTime(self, *args)

    def createdTime(self, *args):
        """
        createdTime(self, vtime arg0)

        Set the time of creation

        """
        return _libvfs.Node_createdTime(self, *args)

    def changedTime(self, *args):
        """
        changedTime(self, vtime arg0)

        Set the time of last change

        """
        return _libvfs.Node_changedTime(self, *args)

    def times(self):
        """
        times(self) -> std::map<(std::string,p.vtime,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.vtime)>)>)>

        Return a map containing the different time informations on a node.

        """
        return _libvfs.Node_times(self)

    def size(self):
        """
        size(self) -> uint64_t

        Return the size of the node

        """
        return _libvfs.Node_size(self)

    def path(self):
        """
        path(self) -> string

        return the path to the node

        """
        return _libvfs.Node_path(self)

    def name(self):
        """
        name(self) -> string

        return the name of the node

        """
        return _libvfs.Node_name(self)

    def absolute(self):
        """
        absolute(self) -> string

        return the absolute path of the node (equivalent to Node::path() + Node::name())

        """
        return _libvfs.Node_absolute(self)

    def isFile(self):
        """
        isFile(self) -> bool

        return true if the node is a file, false otherwise

        """
        return _libvfs.Node_isFile(self)

    def isDir(self):
        """
        isDir(self) -> bool

        return true if the node is a directory, false otherwise

        """
        return _libvfs.Node_isDir(self)

    def isLink(self):
        """
        isLink(self) -> bool

        return true if the node is a link, false otherwise

        """
        return _libvfs.Node_isLink(self)

    def isVDir(self):
        """
        isVDir(self) -> bool

        return true if the node is a link to a directory, false otherwise

        """
        return _libvfs.Node_isVDir(self)

    def isDeleted(self):
        """
        isDeleted(self) -> bool

        return true if the node is deleted, false otherwise

        """
        return _libvfs.Node_isDeleted(self)

    def fsobj(self):
        """
        fsobj(self) -> fso

        return a pointer to fso instance associated with the node

        """
        return _libvfs.Node_fsobj(self)

    def parent(self):
        """
        parent(self) -> Node

        return a pointer to the node which is the parent of the cuurent node.

        """
        return _libvfs.Node_parent(self)

    def children(self):
        """
        children(self) -> VecNode

        return a vector containing pointers to the children of the current node. If the
        node has no child, the vector is empty.

        """
        return _libvfs.Node_children(self)

    def addChild(self, *args):
        """
        addChild(self, Node child) -> bool

        Take a pointer to a node in parameter. This node will be added to the current node
        as one of its child.

        """
        return _libvfs.Node_addChild(self, *args)

    def hasChildren(self):
        """
        hasChildren(self) -> bool

        return true if the node has one or more children, false otherwise

        """
        return _libvfs.Node_hasChildren(self)

    def childCount(self):
        """
        childCount(self) -> uint32_t

        return the number of children the node has

        """
        return _libvfs.Node_childCount(self)

    def open(self):
        """
        open(self) -> VFile

        Open the node and return a pointer to a VFile instance

        """
        return _libvfs.Node_open(self)

    def at(self):
        """
        at(self) -> uint32_t

        1
        """
        return _libvfs.Node_at(self)

    def __iter__(self):
      for node in self.next:  
         yield node

    def __disown__(self):
        self.this.disown()
        _libvfs.disown_Node(self)
        return weakref_proxy(self)

class VfsRoot(Node):
    """1"""

    def __init__(self, *args): 
        """
        __init__(self, string name) -> VfsRoot

        1
        """
        _libvfs.VfsRoot_swiginit(self,_libvfs.new_VfsRoot(*args))

class VLink(Node):
    """
    The class VLink inherits the Node class. It a specific type of Node corresponding
    to a link to an other node. This class can be useful to create nodes \"pointing\"
    on other nodes, such as Linux symbolic links or Windows short-cuts for example.

    Otherwise, the VLink class is pretty similar to the Node class.

    """

    def linkPath(self):
        """
        linkPath(self) -> string

        Return the path to the pointed node.
        """
        return _libvfs.VLink_linkPath(self)

    def linkName(self):
        """
        linkName(self) -> string

        Return the name of the pointed node.
        """
        return _libvfs.VLink_linkName(self)

    def linkAbsolute(self):
        """
        linkAbsolute(self) -> string

        Return the absolute path + name of the pointed node. Is equivalent to
        VLink::linkPath() + "/" + VLink::linkName()
        """
        return _libvfs.VLink_linkAbsolute(self)

    def __init__(self, *args): 
        """
        __init__(self, Node linkedNode, Node parent, string newname = "") -> VLink
        __init__(self, Node linkedNode, Node parent) -> VLink

        Constructor.

        Params :
                * linkedNode
                * parent : the parent's node of the VLink
                * newname : the name of the node (empty by default)
        """

        if self.__class__ == VLink:
            _self = None
        else:
            _self = self
        _libvfs.VLink_swiginit(self,_libvfs.new_VLink(_self, *args))

    def linkParent(self):
        """
        linkParent(self) -> Node

        Return a pointer to the parent node of the pointed node.
        """
        return _libvfs.VLink_linkParent(self)

    def linkChildren(self):
        """
        linkChildren(self) -> VecNode

        Return the list of children of the pointed node.
        """
        return _libvfs.VLink_linkChildren(self)

    def linkHasChildren(self):
        """
        linkHasChildren(self) -> bool

        Return `true` if the pointed node has children, `false` otherwise.
        """
        return _libvfs.VLink_linkHasChildren(self)

    def linkChildCount(self):
        """
        linkChildCount(self) -> uint32_t

        Return the number of child the pointed nodes has.
        """
        return _libvfs.VLink_linkChildCount(self)

    def linkNode(self):
        """
        linkNode(self) -> Node

        Return a pointer to the node pointed by the link.
        """
        return _libvfs.VLink_linkNode(self)

    def __disown__(self):
        self.this.disown()
        _libvfs.disown_VLink(self)
        return weakref_proxy(self)

class fso(object):
    """
    The fso or \'File System Object\' class is the base class of the API. All
    modules must inheritates it. It provides several virtual methods which
    must be reimplemented, such as start, vopen, vread, vwrite, vclose and
    vseek. They are used to read, open, write and seek within the content
    of a node.

    The start method is the first method which is called when a module is
    launched.

    """

    def __init__(self, *args): 
        """
        __init__(self, string name) -> fso

        Constructor.

        Param :
                * name : the nane of the module.
        """
        if self.__class__ == fso:
            _self = None
        else:
            _self = self
        _libvfs.fso_swiginit(self,_libvfs.new_fso(_self, *args))

    def start(self, *args):
        """
        start(self, argument args)

        This method is called when the module starts. It does the job the module
        is supposed to do. This method is declared as a pure virtual so each modules
        must reiplements it (see the developer's documentations for more details) in
        python or C++, depending on which language you choose.

        The parameter 'args' is pointer to the arguments list which were passed to the
        module when it was launched. You can get them by using the method
         args->get(\"arg_name\", &variable)
        where variable must be of the same type than the argument \"arg_name\"

        If you create nodes, you must not forget to call the method register_tree at
        the end of the module execution.

        If an error occured while getting a parameter, a envError exception is thrown.

        Params :
                * args : the list of arguments passed to the module.

        """
        return _libvfs.fso_start(self, *args)

    def vopen(self, *args):
        """
        vopen(self, Node n) -> int32_t

        Open a node.

        Param :
                * n : the node you want to open

        Return the opened file descriptor.

        Unknown behaviour in case of failure...
        """
        return _libvfs.fso_vopen(self, *args)

    def vread(self, *args):
        """
        vread(self, int32_t fd, void rbuff, uint32_t size) -> int32_t

        Perform readings on an open node and returns the number of bytes which wereread.

        Params :
                * fd : the file descriptor of the node you want to read on.
                * rbuff : a pointer to an allocated buffer where the read bytes will be stored
                * size : the number of characters you want to read.

        Return the number of read characters.
        """
        return _libvfs.fso_vread(self, *args)

    def vwrite(self, *args):
        """
        vwrite(self, int32_t fd, void wbuff, uint32_t size) -> int32_t

        Not used.

        """
        return _libvfs.fso_vwrite(self, *args)

    def vclose(self, *args):
        """
        vclose(self, int32_t fd) -> int32_t

        Close an open file descriptor and make it available again for others
        openings.

        Return `0` if everything went fine, `0` otherwise.
        """
        return _libvfs.fso_vclose(self, *args)

    def vseek(self, *args):
        """
        vseek(self, int32_t fd, uint64_t offset, int32_t whence) -> uint64_t

        This method is used to change position within an open node (i.e. modifies the
        offset of the current position). The offset is set to 0 when the file is open.

        Throws a vfsError if something goes wrong (typically if the seeking position is
        after the end of the file).

        It takes three parameters :
                * a file descriptor of an open node
                * the offset where you want to seek
                * the third parameter is optional : it defines if the offset passed in second parameter is absolute or relative.

        Return an uint64_t
        """
        return _libvfs.fso_vseek(self, *args)

    def status(self):
        """
        status(self) -> uint32_t

        Return the status of the module.
        """
        return _libvfs.fso_status(self)

    def vtell(self, *args):
        """
        vtell(self, int32_t fd) -> uint64_t

        Returns the current offset in a file.
        """
        return _libvfs.fso_vtell(self, *args)

    def setVerbose(self, *args):
        """
        setVerbose(self, bool verbose)

        Set the module in verbose mode if the param `verbose` is et to `true`, 
        shutdown the verbose mode otherwise. Verbose mode should not be enabled
        in production environment.

        Params :
                * verbose : the verbosity
        """
        return _libvfs.fso_setVerbose(self, *args)

    def verbose(self):
        """
        verbose(self) -> bool

        Return `true` if the module is in verbose mode, `false` otherwise.

        """
        return _libvfs.fso_verbose(self)

    def updateQueue(self):
        """
        updateQueue(self) -> ListNode

        """
        return _libvfs.fso_updateQueue(self)

    def registerTree(self, *args):
        """
        registerTree(self, Node parent, Node head)

        This method must be called when the modul has finished created all its nodes.
        
        Params :
                * parent : the parent node of the tree
                * head : the head of the tree
        """
        return _libvfs.fso_registerTree(self, *args)

    def __disown__(self):
        self.this.disown()
        _libvfs.disown_fso(self)
        return weakref_proxy(self)

class fdinfo(object):
    """
    Informations on a file descriptor.

    """

    def __init__(self): 
        """
        __init__(self) -> fdinfo

        Constructor.
        """
        _libvfs.fdinfo_swiginit(self,_libvfs.new_fdinfo())

class FdManager(object):
    """
    The FdManager is used to manage all open file descriptors.

    """

    def __init__(self): 
        """
        __init__(self) -> FdManager

        Constructor.
        """
        _libvfs.FdManager_swiginit(self,_libvfs.new_FdManager())

    def get(self, *args):
        """
        get(self, int32_t fd) -> fdinfo

        Return a pointer to the fdinfo structure correponding to file descriptor `fd`

        Params :
                * fd : the file decsriptor on which you want to get the fdinfo structure
        """
        return _libvfs.FdManager_get(self, *args)

    def remove(self, *args):
        """
        remove(self, int32_t fd)

        Free the resources occupied by the fdinfo structure correponding to `fd`
        """
        return _libvfs.FdManager_remove(self, *args)

    def push(self, *args):
        """
        push(self, fdinfo fi) -> int32_t

        Push the fdinfo `fi` into the list of opened file descriptors.
        """
        return _libvfs.FdManager_push(self, *args)

class mfso(fso):
    """
    The mfso class has pretty the same role as the fso one. It inheritates fso.

    The main difference is based on the file mapping explained below: the fso class
    do not use file mapping, mfso uses it. The mfso class provides implementations
    for the vopen, vread and vseek methods and a file descriptor manager. It provides
    an abstraction of the node\'s content to developers, making the code easier to write.

    File mapping is detailed in libvfs.fileMapping.

    """

    def __init__(self, *args): 
        """
        __init__(self, string name) -> mfso

        Constructor.

        Params :
                * name : the name of the module

        """
        if self.__class__ == mfso:
            _self = None
        else:
            _self = self
        _libvfs.mfso_swiginit(self,_libvfs.new_mfso(_self, *args))

    def start(self, *args):
        """
        start(self, argument args)

        This method is called when the module starts. It does the job the module
        is supposed to do. This method is declared as a pure virtual so each modules
        must reiplements it (see the developer\'s documentations for more details) in
        python or C++, depending on which language you choose.

        The parameter \'args\' is pointer to the arguments list which were passed to the
        module when it was launched. You can get them by using the method

          args->get(\"arg_name\", &variable)

        where variable must be of the same type than the argument \"arg_name\"

        If you create nodes, you must not forget to call the method register_tree at
        the end of the module execution.

        If an error occured while getting a parameter, a envError exception is thrown.

        Params :
                * args : the list of arguments.

        """
        return _libvfs.mfso_start(self, *args)

    def vopen(self, *args):
        """
        vopen(self, Node n) -> int32_t

        Open the node `n`.

        Params :
                * n : the node you want to open.
        """
        return _libvfs.mfso_vopen(self, *args)

    def vread(self, *args):
        """
        vread(self, int32_t fd, void buff, uint32_t size) -> int32_t

        Perform readings on an open node and returns the number of bytes which wereread.

        Params :
                * fd : the file descroiptor of the node you want to read on.
                * buff : a pointer to an allocated buffer where the read bytes will be stored
                * size : the number of characters you want to read.

        Throw a vfsError if something goes wrong.

        An implentation of this method is provided with mfso, so developers should not have
        to reimplement it.

        Return the number of read characters.
        """
        return _libvfs.mfso_vread(self, *args)

    def vwrite(self, *args):
        """
        vwrite(self, int32_t fd, void buff, uint32_t size) -> int32_t

        Not used (for now. It might change in the future).
        """
        return _libvfs.mfso_vwrite(self, *args)

    def vclose(self, *args):
        """
        vclose(self, int32_t fd) -> int32_t

        Close an open file descriptor and make it available again for others
        openings.

        An implentation of this method is provided with mfso, so developers should not have
        to reimplement it.

        Params :
                * fd : the file decsriptor you want to close.

        Return 0.
        """
        return _libvfs.mfso_vclose(self, *args)

    def vseek(self, *args):
        """
        vseek(self, int32_t fd, uint64_t offset, int32_t whence) -> uint64_t

        This method is used to change position within an open node (i.e. modifies the
        offset of the current position). The offset is set to 0 when the file is open.

        Throws a vfsError if something goes wrong (typically if the seeking position is
        after the end of the file).

        Params :
                * fd : a file descriptor of an open node
                * offset : the offset where you want to seek
                * whence : the third parameter is optional : it defines if the offset passed in second parameter is absolute or relative.

        An implentation of this method is provided with mfso, so developers should not have
        to reimplement it.
        
        Return of how many bytes the position changed.
        """
        return _libvfs.mfso_vseek(self, *args)

    def status(self):
        """
        status(self) -> uint32_t

        Return the status of the module.
        """
        return _libvfs.mfso_status(self)

    def vtell(self, *args):
        """
        vtell(self, int32_t fd) -> uint64_t

        Returns the current offset in a file.

        An implentation of this method is provided with mfso, so developers should not have
        to reimplement it.

        Param :
                * fd : the file descriptor of the node on which you want to use vtell.
        """
        return _libvfs.mfso_vtell(self, *args)

    def setVerbose(self, *args):
        """
        setVerbose(self, bool verbose)

        Set the module in verbose mode if the param `verbose` is set to `true`, 
        shutdown the verbose mode otherwise.
        """
        return _libvfs.mfso_setVerbose(self, *args)

    def verbose(self):
        """
        verbose(self) -> bool

        Return `true` if the module is in verbose mode, `false` otherwise.
        """
        return _libvfs.mfso_verbose(self)

    def __disown__(self):
        self.this.disown()
        _libvfs.disown_mfso(self)
        return weakref_proxy(self)

class pdata(object):
    """
    Probably used for something

    """

    def __init__(self): 
        """
        __init__(self) -> pdata

        """
        _libvfs.pdata_swiginit(self,_libvfs.new_pdata())

class VFile(object):
    """
    Virtual file

    """

    def __init__(self, *args): 
        """
        __init__(self, int32_t fd, fso fsobj, Node node) -> VFile

        1
        """
        _libvfs.VFile_swiginit(self,_libvfs.new_VFile(*args))

    def node(self):
        """
        node(self) -> Node

        1
        """
        return _libvfs.VFile_node(self)

    def read(self, *args):
        """
        read(self)
        read(self, uint32_t size)
        read(self, void buff, uint32_t size) -> int32_t

        1
        """
        return _libvfs.VFile_read(self, *args)

    def seek(self, *args):
        """
        seek(self, uint64_t offset, char whence) -> uint64_t
        seek(self, uint64_t offset, int32_t whence) -> uint64_t
        seek(self, uint64_t offset) -> uint64_t
        seek(self, int32_t offset, int32_t whence) -> uint64_t

        1
        """
        return _libvfs.VFile_seek(self, *args)

    def write(self, *args):
        """
        write(self, string buff) -> int32_t
        write(self, char buff, uint32_t size) -> int32_t

        1
        """
        return _libvfs.VFile_write(self, *args)

    def close(self):
        """
        close(self) -> int32_t

        1
        """
        return _libvfs.VFile_close(self)

    def search(self, *args):
        """
        search(self, char needle, uint32_t len, char wildcard, uint64_t start = 0,  uint64_t window = (uint64_t) -1, uint32_t count = (uint32_t) -1) -> Listui64
        search(self, char needle, uint32_t len, char wildcard, uint64_t start = 0,  uint64_t window = (uint64_t) -1) -> Listui64
        search(self, char needle, uint32_t len, char wildcard, uint64_t start = 0) -> Listui64
        search(self, char needle, uint32_t len, char wildcard) -> Listui64

        1
        """
        return _libvfs.VFile_search(self, *args)

    def find(self, *args):
        """
        find(self, char needle, uint32_t len, char wildcard, uint64_t start = 0,  uint64_t window = (uint64_t) -1) -> uint64_t
        find(self, char needle, uint32_t len, char wildcard, uint64_t start = 0) -> uint64_t
        find(self, char needle, uint32_t len, char wildcard) -> uint64_t

        1
        """
        return _libvfs.VFile_find(self, *args)

    def count(self, *args):
        """
        count(self, char needle, uint32_t len, char wildcard, uint64_t start = 0,  uint64_t window = (uint64_t) -1) -> uint32_t
        count(self, char needle, uint32_t len, char wildcard, uint64_t start = 0) -> uint32_t
        count(self, char needle, uint32_t len, char wildcard) -> uint32_t

        1
        """
        return _libvfs.VFile_count(self, *args)

    def dfileno(self):
        """
        dfileno(self) -> int32_t

        1
        """
        return _libvfs.VFile_dfileno(self)

    def tell(self):
        """
        tell(self) -> uint64_t

        1
        """
        return _libvfs.VFile_tell(self)

class VecNode(object):
    """1"""

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        1
        """
        return _libvfs.VecNode_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        1
        """
        return _libvfs.VecNode___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        1
        """
        return _libvfs.VecNode___bool__(self)

    def __len__(self):
        """
        __len__(self) -> size_type

        1
        """
        return _libvfs.VecNode___len__(self)

    def pop(self):
        """
        pop(self) -> value_type

        1
        """
        return _libvfs.VecNode_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, difference_type i, difference_type j) -> VecNode

        1
        """
        return _libvfs.VecNode___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, VecNode v)

        1
        """
        return _libvfs.VecNode___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, difference_type i, difference_type j)

        1
        """
        return _libvfs.VecNode___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)

        1
        """
        return _libvfs.VecNode___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> VecNode
        __getitem__(self, difference_type i) -> value_type

        1
        """
        return _libvfs.VecNode___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, VecNode v)
        __setitem__(self, difference_type i, value_type x)

        1
        """
        return _libvfs.VecNode___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, value_type x)

        1
        """
        return _libvfs.VecNode_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        1
        """
        return _libvfs.VecNode_empty(self)

    def size(self):
        """
        size(self) -> size_type

        1
        """
        return _libvfs.VecNode_size(self)

    def clear(self):
        """
        clear(self)

        1
        """
        return _libvfs.VecNode_clear(self)

    def swap(self, *args):
        """
        swap(self, VecNode v)

        1
        """
        return _libvfs.VecNode_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> allocator_type

        1
        """
        return _libvfs.VecNode_get_allocator(self)

    def begin(self):
        """
        begin(self) -> const_iterator

        1
        """
        return _libvfs.VecNode_begin(self)

    def end(self):
        """
        end(self) -> const_iterator

        1
        """
        return _libvfs.VecNode_end(self)

    def rbegin(self):
        """
        rbegin(self) -> const_reverse_iterator

        1
        """
        return _libvfs.VecNode_rbegin(self)

    def rend(self):
        """
        rend(self) -> const_reverse_iterator

        1
        """
        return _libvfs.VecNode_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        1
        """
        return _libvfs.VecNode_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator

        1
        """
        return _libvfs.VecNode_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> VecNode
        __init__(self, VecNode arg0) -> VecNode
        __init__(self, size_type size) -> VecNode
        __init__(self, size_type size, value_type value) -> VecNode

        1
        """
        _libvfs.VecNode_swiginit(self,_libvfs.new_VecNode(*args))
    def push_back(self, *args):
        """
        push_back(self, value_type x)

        1
        """
        return _libvfs.VecNode_push_back(self, *args)

    def front(self):
        """
        front(self) -> value_type

        1
        """
        return _libvfs.VecNode_front(self)

    def back(self):
        """
        back(self) -> value_type

        1
        """
        return _libvfs.VecNode_back(self)

    def assign(self, *args):
        """
        assign(self, size_type n, value_type x)

        1
        """
        return _libvfs.VecNode_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)

        1
        """
        return _libvfs.VecNode_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)

        1
        """
        return _libvfs.VecNode_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(self, size_type n)

        1
        """
        return _libvfs.VecNode_reserve(self, *args)

    def capacity(self):
        """
        capacity(self) -> size_type

        1
        """
        return _libvfs.VecNode_capacity(self)


class ListNode(object):
    """1"""

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        1
        """
        return _libvfs.ListNode_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        1
        """
        return _libvfs.ListNode___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        1
        """
        return _libvfs.ListNode___bool__(self)

    def __len__(self):
        """
        __len__(self) -> size_type

        1
        """
        return _libvfs.ListNode___len__(self)

    def pop(self):
        """
        pop(self) -> value_type

        1
        """
        return _libvfs.ListNode_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, difference_type i, difference_type j) -> ListNode

        1
        """
        return _libvfs.ListNode___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, ListNode v)

        1
        """
        return _libvfs.ListNode___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, difference_type i, difference_type j)

        1
        """
        return _libvfs.ListNode___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)

        1
        """
        return _libvfs.ListNode___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> ListNode
        __getitem__(self, difference_type i) -> value_type

        1
        """
        return _libvfs.ListNode___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, ListNode v)
        __setitem__(self, difference_type i, value_type x)

        1
        """
        return _libvfs.ListNode___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, value_type x)

        1
        """
        return _libvfs.ListNode_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        1
        """
        return _libvfs.ListNode_empty(self)

    def size(self):
        """
        size(self) -> size_type

        1
        """
        return _libvfs.ListNode_size(self)

    def clear(self):
        """
        clear(self)

        1
        """
        return _libvfs.ListNode_clear(self)

    def swap(self, *args):
        """
        swap(self, ListNode v)

        1
        """
        return _libvfs.ListNode_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> allocator_type

        1
        """
        return _libvfs.ListNode_get_allocator(self)

    def begin(self):
        """
        begin(self) -> const_iterator

        1
        """
        return _libvfs.ListNode_begin(self)

    def end(self):
        """
        end(self) -> const_iterator

        1
        """
        return _libvfs.ListNode_end(self)

    def rbegin(self):
        """
        rbegin(self) -> const_reverse_iterator

        1
        """
        return _libvfs.ListNode_rbegin(self)

    def rend(self):
        """
        rend(self) -> const_reverse_iterator

        1
        """
        return _libvfs.ListNode_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        1
        """
        return _libvfs.ListNode_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator

        1
        """
        return _libvfs.ListNode_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> ListNode
        __init__(self, ListNode arg0) -> ListNode
        __init__(self, size_type size) -> ListNode
        __init__(self, size_type size, value_type value) -> ListNode

        1
        """
        _libvfs.ListNode_swiginit(self,_libvfs.new_ListNode(*args))
    def push_back(self, *args):
        """
        push_back(self, value_type x)

        1
        """
        return _libvfs.ListNode_push_back(self, *args)

    def front(self):
        """
        front(self) -> value_type

        1
        """
        return _libvfs.ListNode_front(self)

    def back(self):
        """
        back(self) -> value_type

        1
        """
        return _libvfs.ListNode_back(self)

    def assign(self, *args):
        """
        assign(self, size_type n, value_type x)

        1
        """
        return _libvfs.ListNode_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)

        1
        """
        return _libvfs.ListNode_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)

        1
        """
        return _libvfs.ListNode_insert(self, *args)

    def pop_front(self):
        """
        pop_front(self)

        1
        """
        return _libvfs.ListNode_pop_front(self)

    def push_front(self, *args):
        """
        push_front(self, value_type x)

        1
        """
        return _libvfs.ListNode_push_front(self, *args)

    def remove(self, *args):
        """
        remove(self, value_type x)

        1
        """
        return _libvfs.ListNode_remove(self, *args)

    def unique(self):
        """
        unique(self)

        1
        """
        return _libvfs.ListNode_unique(self)

    def reverse(self):
        """
        reverse(self)

        1
        """
        return _libvfs.ListNode_reverse(self)

    def sort(self):
        """
        sort(self)

        1
        """
        return _libvfs.ListNode_sort(self)

    def merge(self, *args):
        """
        merge(self, ListNode x)

        1
        """
        return _libvfs.ListNode_merge(self, *args)


class SetNode(object):
    """1"""

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        1
        """
        return _libvfs.SetNode_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        1
        """
        return _libvfs.SetNode___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        1
        """
        return _libvfs.SetNode___bool__(self)

    def __len__(self):
        """
        __len__(self) -> size_type

        1
        """
        return _libvfs.SetNode___len__(self)

    def append(self, *args):
        """
        append(self, value_type x)

        1
        """
        return _libvfs.SetNode_append(self, *args)

    def __contains__(self, *args):
        """
        __contains__(self, value_type x) -> bool

        1
        """
        return _libvfs.SetNode___contains__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, difference_type i) -> value_type

        1
        """
        return _libvfs.SetNode___getitem__(self, *args)

    def __init__(self, *args): 
        """
        __init__(self, std::less<(p.Node)> arg0) -> SetNode
        __init__(self) -> SetNode
        __init__(self, SetNode arg0) -> SetNode

        1
        """
        _libvfs.SetNode_swiginit(self,_libvfs.new_SetNode(*args))
    def empty(self):
        """
        empty(self) -> bool

        1
        """
        return _libvfs.SetNode_empty(self)

    def size(self):
        """
        size(self) -> size_type

        1
        """
        return _libvfs.SetNode_size(self)

    def clear(self):
        """
        clear(self)

        1
        """
        return _libvfs.SetNode_clear(self)

    def swap(self, *args):
        """
        swap(self, SetNode v)

        1
        """
        return _libvfs.SetNode_swap(self, *args)

    def count(self, *args):
        """
        count(self, key_type x) -> size_type

        1
        """
        return _libvfs.SetNode_count(self, *args)

    def begin(self):
        """
        begin(self) -> iterator

        1
        """
        return _libvfs.SetNode_begin(self)

    def end(self):
        """
        end(self) -> iterator

        1
        """
        return _libvfs.SetNode_end(self)

    def rbegin(self):
        """
        rbegin(self) -> reverse_iterator

        1
        """
        return _libvfs.SetNode_rbegin(self)

    def rend(self):
        """
        rend(self) -> reverse_iterator

        1
        """
        return _libvfs.SetNode_rend(self)

    def erase(self, *args):
        """
        erase(self, key_type x) -> size_type
        erase(self, iterator pos)
        erase(self, iterator first, iterator last)

        1
        """
        return _libvfs.SetNode_erase(self, *args)

    def find(self, *args):
        """
        find(self, key_type x) -> iterator

        1
        """
        return _libvfs.SetNode_find(self, *args)

    def lower_bound(self, *args):
        """
        lower_bound(self, key_type x) -> iterator

        1
        """
        return _libvfs.SetNode_lower_bound(self, *args)

    def upper_bound(self, *args):
        """
        upper_bound(self, key_type x) -> iterator

        1
        """
        return _libvfs.SetNode_upper_bound(self, *args)

    def equal_range(self, *args):
        """
        equal_range(self, key_type x) -> std::pair<(std::set<(p.Node)>::iterator,std::set<(p.Node)>::iterator)>

        1
        """
        return _libvfs.SetNode_equal_range(self, *args)

    def insert(self, *args):
        """
        insert(self, value_type __x) -> std::pair<(std::set<(p.Node)>::iterator,bool)>

        1
        """
        return _libvfs.SetNode_insert(self, *args)


class VectChunck(object):
    """1"""

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        1
        """
        return _libvfs.VectChunck_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        1
        """
        return _libvfs.VectChunck___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        1
        """
        return _libvfs.VectChunck___bool__(self)

    def __len__(self):
        """
        __len__(self) -> size_type

        1
        """
        return _libvfs.VectChunck___len__(self)

    def pop(self):
        """
        pop(self) -> value_type

        1
        """
        return _libvfs.VectChunck_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, difference_type i, difference_type j) -> VectChunck

        1
        """
        return _libvfs.VectChunck___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, VectChunck v)

        1
        """
        return _libvfs.VectChunck___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, difference_type i, difference_type j)

        1
        """
        return _libvfs.VectChunck___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)

        1
        """
        return _libvfs.VectChunck___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> VectChunck
        __getitem__(self, difference_type i) -> value_type

        1
        """
        return _libvfs.VectChunck___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, VectChunck v)
        __setitem__(self, difference_type i, value_type x)

        1
        """
        return _libvfs.VectChunck___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, value_type x)

        1
        """
        return _libvfs.VectChunck_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        1
        """
        return _libvfs.VectChunck_empty(self)

    def size(self):
        """
        size(self) -> size_type

        1
        """
        return _libvfs.VectChunck_size(self)

    def clear(self):
        """
        clear(self)

        1
        """
        return _libvfs.VectChunck_clear(self)

    def swap(self, *args):
        """
        swap(self, VectChunck v)

        1
        """
        return _libvfs.VectChunck_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> allocator_type

        1
        """
        return _libvfs.VectChunck_get_allocator(self)

    def begin(self):
        """
        begin(self) -> const_iterator

        1
        """
        return _libvfs.VectChunck_begin(self)

    def end(self):
        """
        end(self) -> const_iterator

        1
        """
        return _libvfs.VectChunck_end(self)

    def rbegin(self):
        """
        rbegin(self) -> const_reverse_iterator

        1
        """
        return _libvfs.VectChunck_rbegin(self)

    def rend(self):
        """
        rend(self) -> const_reverse_iterator

        1
        """
        return _libvfs.VectChunck_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        1
        """
        return _libvfs.VectChunck_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator

        1
        """
        return _libvfs.VectChunck_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> VectChunck
        __init__(self, VectChunck arg0) -> VectChunck
        __init__(self, size_type size) -> VectChunck
        __init__(self, size_type size, value_type value) -> VectChunck

        1
        """
        _libvfs.VectChunck_swiginit(self,_libvfs.new_VectChunck(*args))
    def push_back(self, *args):
        """
        push_back(self, value_type x)

        1
        """
        return _libvfs.VectChunck_push_back(self, *args)

    def front(self):
        """
        front(self) -> value_type

        1
        """
        return _libvfs.VectChunck_front(self)

    def back(self):
        """
        back(self) -> value_type

        1
        """
        return _libvfs.VectChunck_back(self)

    def assign(self, *args):
        """
        assign(self, size_type n, value_type x)

        1
        """
        return _libvfs.VectChunck_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)

        1
        """
        return _libvfs.VectChunck_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)

        1
        """
        return _libvfs.VectChunck_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(self, size_type n)

        1
        """
        return _libvfs.VectChunck_reserve(self, *args)

    def capacity(self):
        """
        capacity(self) -> size_type

        1
        """
        return _libvfs.VectChunck_capacity(self)


class Listui64(object):
    """1"""

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        1
        """
        return _libvfs.Listui64_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        1
        """
        return _libvfs.Listui64___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        1
        """
        return _libvfs.Listui64___bool__(self)

    def __len__(self):
        """
        __len__(self) -> std::list<(unsigned long long)>::size_type

        1
        """
        return _libvfs.Listui64___len__(self)

    def pop(self):
        """
        pop(self) -> std::list<(unsigned long long)>::value_type

        1
        """
        return _libvfs.Listui64_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, std::list<(unsigned long long)>::difference_type i, 
            std::list<(unsigned long long)>::difference_type j) -> Listui64

        1
        """
        return _libvfs.Listui64___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, std::list<(unsigned long long)>::difference_type i, 
            std::list<(unsigned long long)>::difference_type j, 
            Listui64 v)

        1
        """
        return _libvfs.Listui64___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, std::list<(unsigned long long)>::difference_type i, 
            std::list<(unsigned long long)>::difference_type j)

        1
        """
        return _libvfs.Listui64___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, std::list<(unsigned long long)>::difference_type i)
        __delitem__(self, PySliceObject slice)

        1
        """
        return _libvfs.Listui64___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> Listui64
        __getitem__(self, std::list<(unsigned long long)>::difference_type i) -> std::list<(unsigned long long)>::value_type

        1
        """
        return _libvfs.Listui64___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, Listui64 v)
        __setitem__(self, std::list<(unsigned long long)>::difference_type i, 
            std::list<(unsigned long long)>::value_type x)

        1
        """
        return _libvfs.Listui64___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, std::list<(unsigned long long)>::value_type x)

        1
        """
        return _libvfs.Listui64_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        1
        """
        return _libvfs.Listui64_empty(self)

    def size(self):
        """
        size(self) -> std::list<(unsigned long long)>::size_type

        1
        """
        return _libvfs.Listui64_size(self)

    def clear(self):
        """
        clear(self)

        1
        """
        return _libvfs.Listui64_clear(self)

    def swap(self, *args):
        """
        swap(self, Listui64 v)

        1
        """
        return _libvfs.Listui64_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> std::list<(unsigned long long)>::allocator_type

        1
        """
        return _libvfs.Listui64_get_allocator(self)

    def begin(self):
        """
        begin(self) -> std::list<(unsigned long long)>::const_iterator

        1
        """
        return _libvfs.Listui64_begin(self)

    def end(self):
        """
        end(self) -> std::list<(unsigned long long)>::const_iterator

        1
        """
        return _libvfs.Listui64_end(self)

    def rbegin(self):
        """
        rbegin(self) -> std::list<(unsigned long long)>::const_reverse_iterator

        1
        """
        return _libvfs.Listui64_rbegin(self)

    def rend(self):
        """
        rend(self) -> std::list<(unsigned long long)>::const_reverse_iterator

        1
        """
        return _libvfs.Listui64_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        1
        """
        return _libvfs.Listui64_pop_back(self)

    def erase(self, *args):
        """
        erase(self, std::list<(unsigned long long)>::iterator pos) -> std::list<(unsigned long long)>::iterator
        erase(self, std::list<(unsigned long long)>::iterator first, std::list<(unsigned long long)>::iterator last) -> std::list<(unsigned long long)>::iterator

        1
        """
        return _libvfs.Listui64_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> Listui64
        __init__(self, Listui64 arg0) -> Listui64
        __init__(self, std::list<(unsigned long long)>::size_type size) -> Listui64
        __init__(self, std::list<(unsigned long long)>::size_type size, std::list<(unsigned long long)>::value_type value) -> Listui64

        1
        """
        _libvfs.Listui64_swiginit(self,_libvfs.new_Listui64(*args))
    def push_back(self, *args):
        """
        push_back(self, std::list<(unsigned long long)>::value_type x)

        1
        """
        return _libvfs.Listui64_push_back(self, *args)

    def front(self):
        """
        front(self) -> std::list<(unsigned long long)>::value_type

        1
        """
        return _libvfs.Listui64_front(self)

    def back(self):
        """
        back(self) -> std::list<(unsigned long long)>::value_type

        1
        """
        return _libvfs.Listui64_back(self)

    def assign(self, *args):
        """
        assign(self, std::list<(unsigned long long)>::size_type n, std::list<(unsigned long long)>::value_type x)

        1
        """
        return _libvfs.Listui64_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, std::list<(unsigned long long)>::size_type new_size)
        resize(self, std::list<(unsigned long long)>::size_type new_size, 
            std::list<(unsigned long long)>::value_type x)

        1
        """
        return _libvfs.Listui64_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, std::list<(unsigned long long)>::iterator pos, std::list<(unsigned long long)>::value_type x) -> std::list<(unsigned long long)>::iterator
        insert(self, std::list<(unsigned long long)>::iterator pos, std::list<(unsigned long long)>::size_type n, 
            std::list<(unsigned long long)>::value_type x)

        1
        """
        return _libvfs.Listui64_insert(self, *args)

    def pop_front(self):
        """
        pop_front(self)

        1
        """
        return _libvfs.Listui64_pop_front(self)

    def push_front(self, *args):
        """
        push_front(self, std::list<(unsigned long long)>::value_type x)

        1
        """
        return _libvfs.Listui64_push_front(self, *args)

    def reverse(self):
        """
        reverse(self)

        1
        """
        return _libvfs.Listui64_reverse(self)

